#+TITLE:       The Standard C Library(C标准库)(study record)
#+AUTHOR:      辛佳斌(lawrence)
#+DATE:        [2017-02-13 周一 16:31]
#+EMAIL:       lawrencejiabin@163.com
#+KEYWORDS:    stdio.h C/C++ C
#+LANGUAGE:    ANSI/ISO C语言标准 库函数

#+SEQ_TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f)
#+SEQ_TODO: TODO(T!) | DONE(D@)3  CANCELED(C@/!)  

* 概述
** 注意要点
总结隐藏在C标准库的晦涩陷进，对应的使用规范。
编写具有工业强度的健壮代码所需的技巧。
为适应不同文化习惯，引入的编程艺术。
如何做到在各种计算机体系结构间具有高度可移植性。
兼顾正确性、性能和代码规模。

** 15个头文件/3个层次
- 合格:<ctype.h>、<stdio.h>、<stdlib.h>、<string.h>;
- 熟练:<assert.h>、<limits.h>、<stddef.h>、<time.h>;
- 优秀:<float.h>、<math.h>、<error.h>、<locale.h>、<setjmp.h>、<signal.h>、<stdarg.h>;
|   合格   |   熟练   |   优秀   |
|----------+----------+----------|
| ctype.h  | assert.h | float.h  |
| stdio.h  | limits.h | math.h   |
| stdlib.h | stddef.h | error.h  |
| string.h | time.h   | locale.h |
|          |          | setjmp.h |
|          |          | signal.h |
|          |          | stdarg.h |

** 库的设计
构建一个库要求具备的技能：数值分析、字符串操作、操作系统接口
设计原则：结构化设计、结构化分析、结构化编程、面向对象设计、实现可复用的数据抽象、可重入设计
          高内聚 --> 易拓展
          低耦合 --> 易使用
          做到隐藏实现细节并且提供完整的功能。
          达到正确性、可维护性、高性能、可移植性、小规模。

** 公共测试程序
Plum Hall Validation Suite的库函数测试。
专门为C实现设计、发现C实现的缺陷的公共域程序。

** 库的分层
+ 只有在和计算机体系结构有关，才用 ~汇编语言~ ，或尽量利用编译器。
+ 尽可能把 ~不可移植的代码~ 独立出来。
+ 几乎都可用 =可移植C语言= 编写。
需要做到如何区分这3类代码，并加以分层？

** C标准
一个标准首先一定是准确和严密的，其次是才考虑可读性。因此不适合当作学习教程。

** 括号抑制宏展开
在一个函数名字，同时存在宏定义和函数定义时，
通过在调用时，在函数名加上一对括号，可抑制被宏定义所展开，明确定义为函数应用。
#+BEGIN_EXAMPLE
i = (atoi) (str);
#+END_EXAMPLE

** 命名空间
P8页 图0-1展示了C程序存在的命名空间
注意各种类型名字的优先级：
宏 > 关键字 > 最内层代码块 > 倒数第二层代码块 > ...(每一对大括号为一层代码块) > 文件层次
不要使用保留的名字规则，以下划线开头，以2个下划线开头，的命名。

** 库的实现假设
最好的做法是，C库要和对应的编译器搭配，比如：gcc和glibc一起搭配。
不搭配可能会引起一些冲突。

** 文件大小
每一个编译器在翻译大文件时候，都会有不能成功翻译的可能。
尽量切割文件代码，控制文件的代码长度。

** 头文件使用宏保护
#+BEGIN_SRC C/C++
  #ifndef _STDIO_H
  #define _STDIO_H
     ....
  #endif
#+END_SRC
但是对于<assert.h>,受宏名NDEBUG的控制，因此不能使用宏保护。

** 库的测试
在代码测试之前应该设计一个测试计划，应该让不同的程序员来写代码和测试代码，必须建立代码修改后的重新测试制度。
为每一个功能，建立一个单独的测试库和对应的测试程序，简化以后修改带来的测试。
建立一个测试制度，方便加载测试功能和移除测试功能。
可以在每个测试程序添加调试功能，方便抓取数据和信息。

* <assert.h>
** 静止形式
#+BEGIN_SRC C/C++
  #define assert(ignore)  ((void)0)
  (void)0; == nop;//相当于空语句
#+END_SRC
对于(void)0;这样的语句编译器是怎么处理的。
** assert的测试方针
+ 宏不能直接调用库的任何输出函数。
+ 宏必须拓展成一个 ~void类型的表达式~。
+ 宏一个拓展成有效并且紧凑的代码。
** 内置宏的额外处理层
内置宏__LINE__没有拓展成字符串字面量，而是十进制变量。
_STR():用十进制常量拓展取代__LINE__,
_VAL():把十进制常量转换为一个字符串字面量。
#+BEGIN_SRC
  #define _STR(x) _VAL(x)
  #define _VAL(x) #x
  _STR(__LINE__)
  宏是逐层替换的吗？？
#+END_SRC
** 内置宏拓展
编译器内置宏是怎么进行拓展的，如何防拓展。
__LINE__:
__FILE__:
** :冒号用法
:(冒号)：
** 井号用法
#：将其后面的宏参数进行 ~字符串化~ 操作（Stringfication），
   简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。
##：被称为连接符（concatenator），用来将两个Token连接为一个Token。
** 程序桩
程序插桩：是借助往被测程序中插入操作，来实现测试目的的方法。
          在调试程序时，常常在程序中插入一些打印语句，
          在执行程序时，打印出我们最为关系的信息，
          通过这些信息了解执行过程中程序的一些动态特性。
桩模块：集成测试前要为被测模块编制一些模拟其下级模块功能的“替身”模块，
        以代替被测模块的接口，接受或传递被测模块的数据，
        这些专供测试用的“假”模块称为被测模块的桩模块。

* <ctype.h>
** 宏定义参数的副作用
#+BEGIN_SRC
  #define SQUARE(x) x*x
  a = 3;
  b = SQUARE(a++);///b = a++*a++;此形式C标准未定义
#+END_SRC
